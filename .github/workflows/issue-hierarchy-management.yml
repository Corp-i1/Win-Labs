name: Issue Hierarchy Management

on:
  issues:
    types: [opened, edited]

jobs:
  manage-issue-hierarchy:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.ISSUE_MANAGEMENT }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Process Issue Hierarchy
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.ISSUE_MANAGEMENT }}
        script: |
          const issue = context.payload.issue;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          
          // Validate required inputs
          if (!issue) {
            core.setFailed('No issue found in payload');
            return;
          }
          
          if (!owner || !repo) {
            core.setFailed('Repository owner or name not found');
            return;
          }
          
          // Function to extract parent issue number from issue body/title
          function extractParentIssue(text) {
            const parentPatterns = [
              /Parent:?\s*#(\d+)/i,
              /Parent\s+issue:?\s*#(\d+)/i,
              /Depends\s+on:?\s*#(\d+)/i,
              /Child\s+of:?\s*#(\d+)/i,
              /Sub-task\s+of:?\s*#(\d+)/i
            ];
            
            for (const pattern of parentPatterns) {
              const match = text.match(pattern);
              if (match) {
                return parseInt(match[1]);
              }
            }
            return null;
          }
          
          // Function to get all parent issues recursively
          async function getParentChain(issueNumber) {
            const chain = [];
            let currentIssue = issueNumber;
            
            while (currentIssue) {
              try {
                const { data: issueData } = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: currentIssue
                });
                
                const parentNumber = extractParentIssue(issueData.body || '');
                if (parentNumber && parentNumber !== currentIssue) {
                  chain.push(parentNumber);
                  currentIssue = parentNumber;
                } else {
                  break;
                }
              } catch (error) {
                console.log(`Could not fetch issue #${currentIssue}: ${error.message}`);
                break;
              }
            }
            
            return chain;
          }
          
          // Function to create branch name from issue
          function createBranchName(issueNumber, title) {
            const sanitized = title
              .toLowerCase()
              .replace(/[^a-z0-9\s-]/g, '')
              .replace(/\s+/g, '-')
              .substring(0, 40);
            return `issue-${issueNumber}-${sanitized}`;
          }
          
          // Function to check if branch exists
          async function branchExists(branchName) {
            try {
              await github.rest.repos.getBranch({
                owner,
                repo,
                branch: branchName
              });
              return true;
            } catch (error) {
              return false;
            }
          }
          
          // Function to check if PR exists for an issue
          async function getPullRequestForIssue(issueNumber) {
            try {
              const { data: prs } = await github.rest.pulls.list({
                owner,
                repo,
                state: 'open'
              });
              
              for (const pr of prs) {
                // Check if PR body or title references the issue
                const prText = `${pr.title} ${pr.body || ''}`;
                if (prText.includes(`#${issueNumber}`) || 
                    prText.includes(`issue ${issueNumber}`) ||
                    pr.head.ref.includes(`issue-${issueNumber}`)) {
                  return pr;
                }
              }
              return null;
            } catch (error) {
              console.log(`Error checking PRs: ${error.message}`);
              return null;
            }
          }
          
          // Function to merge child branch commits into parent branch
          async function mergeBranchIntoParent(childBranch, parentBranch) {
            try {
              // Get commits from child branch that are not in parent branch
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner,
                repo,
                base: parentBranch,
                head: childBranch
              });
              
              if (comparison.ahead_by === 0) {
                console.log(`No commits to merge from ${childBranch} to ${parentBranch}`);
                return true;
              }
              
              // Create a merge commit
              await github.rest.repos.merge({
                owner,
                repo,
                base: parentBranch,
                head: childBranch,
                commit_message: `Merge commits from ${childBranch} into ${parentBranch}\n\nAutomatically merged due to issue reparenting`
              });
              
              console.log(`Successfully merged ${comparison.ahead_by} commits from ${childBranch} to ${parentBranch}`);
              return true;
            } catch (error) {
              console.error(`Error merging branches: ${error.message}`);
              
              // Check if it's a merge conflict
              if (error.message.includes('conflict') || error.message.includes('Merge conflict')) {
                console.log('Merge conflict detected - will require manual resolution');
              } else {
                console.error('Unexpected merge error:', error);
              }
              
              return false;
            }
          }
          
          // Function to handle issue reparenting
          async function handleReparentedIssue(childIssueNumber, parentIssueNumber) {
            if (!childIssueNumber || !parentIssueNumber) {
              throw new Error(`Invalid issue numbers: child=${childIssueNumber}, parent=${parentIssueNumber}`);
            }
            
            if (childIssueNumber === parentIssueNumber) {
              throw new Error(`Issue cannot be parent of itself: #${childIssueNumber}`);
            }
            
            try {
              console.log(`Handling reparented issue #${childIssueNumber} -> parent #${parentIssueNumber}`);
              
              // Get existing PR for child issue
              const childPR = await getPullRequestForIssue(childIssueNumber);
              if (!childPR) {
                console.log(`No existing PR found for child issue #${childIssueNumber}`);
                return;
              }
              
              console.log(`Found existing PR #${childPR.number} for child issue #${childIssueNumber}`);
              
              // Ensure parent has a branch and PR
              const parentPR = await getPullRequestForIssue(parentIssueNumber);
              if (!parentPR) {
                console.log(`Parent issue #${parentIssueNumber} needs branch and PR`);
                await createBranchAndPR(parentIssueNumber);
              }
              
              // Get parent PR again after potential creation
              const updatedParentPR = await getPullRequestForIssue(parentIssueNumber);
              if (!updatedParentPR) {
                throw new Error(`Failed to ensure parent PR exists for issue #${parentIssueNumber}`);
              }
              
              // Merge child branch commits into parent branch
              const mergeSuccess = await mergeBranchIntoParent(childPR.head.ref, updatedParentPR.head.ref);
              
              if (mergeSuccess) {
                // Update child PR to indicate it's been merged into parent
                const updatedBody = `
                ‚ö†Ô∏è **This PR has been superseded by PR #${updatedParentPR.number}**
                
                This issue was reparented and all commits have been merged into the parent PR.
                
                Original description:
                ${childPR.body}
                
                See PR #${updatedParentPR.number} for continued work.
                `;
                
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: childPR.number,
                  state: 'closed',
                  body: updatedBody.trim()
                });
                
                // Add comments to both PRs
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: childPR.number,
                  body: `üîÑ This PR has been closed and merged into PR #${updatedParentPR.number} due to issue reparenting.`
                });
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: updatedParentPR.number,
                  body: `üîÑ Merged commits from PR #${childPR.number} (issue #${childIssueNumber}) due to issue reparenting.`
                });
                
                // Add comment to child issue
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: childIssueNumber,
                  body: `üîÑ Work for this issue has been consolidated into PR #${updatedParentPR.number} (parent issue #${parentIssueNumber}).`
                });
                
                // Delete the child branch
                try {
                  await github.rest.git.deleteRef({
                    owner,
                    repo,
                    ref: `heads/${childPR.head.ref}`
                  });
                  console.log(`Deleted child branch: ${childPR.head.ref}`);
                } catch (deleteError) {
                  console.log(`Could not delete branch ${childPR.head.ref}: ${deleteError.message}`);
                }
                
                console.log(`Successfully handled reparenting of issue #${childIssueNumber}`);
              } else {
                // If merge failed, just mark the child PR as dependent
                const updatedBody = `
                ‚ö†Ô∏è **This issue is now a child of issue #${parentIssueNumber}**
                
                This PR should be coordinated with PR #${updatedParentPR.number}.
                
                Original description:
                ${childPR.body}
                
                **Note**: Automatic merge failed, manual coordination required.
                `;
                
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: childPR.number,
                  body: updatedBody.trim(),
                  draft: true
                });
                
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: childPR.number,
                  body: `‚ö†Ô∏è This PR is now dependent on PR #${updatedParentPR.number}. Manual coordination required - automatic merge failed.`
                });
              }
              
            } catch (error) {
              console.error(`Error handling reparented issue #${childIssueNumber}: ${error.message}`);
              
              // Add error comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: childIssueNumber,
                body: `‚ùå Failed to automatically handle issue reparenting: ${error.message}`
              });
            }
          }
          
          // Function to create branch and PR for an issue
          async function createBranchAndPR(issueNumber) {
            if (!issueNumber || issueNumber <= 0) {
              throw new Error(`Invalid issue number: ${issueNumber}`);
            }
            
            try {
              const { data: issueData } = await github.rest.issues.get({
                owner,
                repo,
                issue_number: issueNumber
              });
              
              if (!issueData) {
                throw new Error(`Issue #${issueNumber} not found`);
              }
              
              const branchName = createBranchName(issueNumber, issueData.title);
              
              // Check if branch already exists
              if (await branchExists(branchName)) {
                console.log(`Branch ${branchName} already exists for issue #${issueNumber}`);
                return;
              }
              
              // Get default branch reference
              const { data: defaultBranch } = await github.rest.repos.getBranch({
                owner,
                repo,
                branch: context.payload.repository.default_branch
              });
              
              // Create new branch
              await github.rest.git.createRef({
                owner,
                repo,
                ref: `refs/heads/${branchName}`,
                sha: defaultBranch.commit.sha
              });
              
              console.log(`Created branch: ${branchName}`);
              
              // Create an initial commit to the branch
              const initialCommitMessage = `Initialize branch for issue #${issueNumber}` + 
                `\n\n${issueData.title}` + 
                `\n\nThis branch was automatically created for issue #${issueNumber}.`;
              
              // Create a README file for this issue
              const readmeContent = `# Issue #${issueNumber}: ${issueData.title}

## Description
${issueData.body || 'No description provided'}

## Progress
- [ ] Work in progress

---
This branch was automatically created by the issue hierarchy management workflow.
`;
              
              // Create blob for README
              const { data: blob } = await github.rest.git.createBlob({
                owner,
                repo,
                content: Buffer.from(readmeContent).toString('base64'),
                encoding: 'base64'
              });
              
              // Get current tree
              const { data: baseTree } = await github.rest.git.getTree({
                owner,
                repo,
                tree_sha: defaultBranch.commit.sha
              });
              
              // Create new tree with README
              const { data: newTree } = await github.rest.git.createTree({
                owner,
                repo,
                base_tree: baseTree.sha,
                tree: [{
                  path: `docs/issue-${issueNumber}.md`,
                  mode: '100644',
                  type: 'blob',
                  sha: blob.sha
                }]
              });
              
              // Create commit
              const { data: newCommit } = await github.rest.git.createCommit({
                owner,
                repo,
                message: initialCommitMessage,
                tree: newTree.sha,
                parents: [defaultBranch.commit.sha]
              });
              
              // Update branch reference
              await github.rest.git.updateRef({
                owner,
                repo,
                ref: `heads/${branchName}`,
                sha: newCommit.sha
              });
              
              console.log(`Added initial commit to branch: ${branchName}`);
              
              // Check if PR already exists
              const existingPR = await getPullRequestForIssue(issueNumber);
              if (existingPR) {
                console.log(`PR already exists for issue #${issueNumber}: ${existingPR.html_url}`);
                return;
              }
              
              // Create pull request
              const prBody = `
              Automatically created PR for issue #${issueNumber}
              
              ## Issue Description
              ${issueData.body || 'No description provided'}
              
              ## Checklist
              - [ ] Implementation completed
              - [ ] Tests added/updated
              - [ ] Documentation updated
              - [ ] Code reviewed
              
              Closes #${issueNumber}
              `;
              
              const { data: pr } = await github.rest.pulls.create({
                owner,
                repo,
                title: `${issueData.title} (#${issueNumber})`,
                head: branchName,
                base: context.payload.repository.default_branch,
                body: prBody.trim(),
                draft: true
              });
              
              console.log(`Created PR: ${pr.html_url}`);
              
              // Add comment to issue
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: `ü§ñ Automatically created branch \`${branchName}\` and draft PR #${pr.number} for this issue.`
              });
              
            } catch (error) {
              console.error(`Error creating branch/PR for issue #${issueNumber}: ${error.message}`);
              
              // Add error comment to issue
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: `‚ùå Failed to automatically create branch and PR: ${error.message}`
              });
            }
          }
          
          // Main logic wrapped in try-catch
          try {
            console.log(`Processing issue #${issue.number}: ${issue.title}`);
            
            // Check if this issue has a parent
            const parentIssueNumber = extractParentIssue(`${issue.title} ${issue.body || ''}`);
            
            // Check if this issue previously had no parent but now has one (reparenting scenario)
            const existingChildPR = await getPullRequestForIssue(issue.number);
            
            if (parentIssueNumber) {
              console.log(`Issue #${issue.number} has parent: #${parentIssueNumber}`);
              
              // If this issue has an existing PR and now has a parent, handle reparenting
              if (existingChildPR) {
                console.log(`Issue #${issue.number} has existing PR #${existingChildPR.number} and is being reparented`);
                await handleReparentedIssue(issue.number, parentIssueNumber);
              }
              
              // Get the full parent chain
              const parentChain = await getParentChain(issue.number);
              console.log(`Parent chain: ${parentChain.join(' -> ')}`);
              
              // Process each parent in the chain (from root to immediate parent)
              const rootParent = parentChain[parentChain.length - 1];
              if (rootParent) {
                console.log(`Processing root parent: #${rootParent}`);
                
                // Check if root parent has a PR
                const existingPR = await getPullRequestForIssue(rootParent);
                if (!existingPR) {
                  console.log(`Root parent #${rootParent} needs branch and PR`);
                  await createBranchAndPR(rootParent);
                } else {
                  console.log(`Root parent #${rootParent} already has PR: ${existingPR.html_url}`);
                }
                
                // Add comment to current issue linking to parent PR (only if not reparented)
                if (!existingChildPR) {
                  const parentPR = await getPullRequestForIssue(rootParent);
                  if (parentPR) {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issue.number,
                      body: `üîó This issue is part of the work tracked in PR #${parentPR.number} (for issue #${rootParent})`
                    });
                  }
                }
              }
            } else {
              console.log(`Issue #${issue.number} has no parent - this is a root issue`);
              
              // This is a root issue, create branch and PR for it if it doesn't exist
              if (!existingChildPR) {
                console.log(`Root issue #${issue.number} needs branch and PR`);
                await createBranchAndPR(issue.number);
              } else {
                console.log(`Root issue #${issue.number} already has PR: ${existingChildPR.html_url}`);
              }
            }
            
            console.log(`Successfully completed processing for issue #${issue.number}`);
            
          } catch (mainError) {
            console.error(`Critical error processing issue #${issue.number}: ${mainError.message}`);
            
            // Try to add error comment to issue
            try {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.number,
                body: `‚ùå **Workflow Error**: Failed to process issue hierarchy: ${mainError.message}`
              });
            } catch (commentError) {
              console.error(`Failed to add error comment: ${commentError.message}`);
            }
            
            // Fail the action
            core.setFailed(`Issue hierarchy processing failed: ${mainError.message}`);
          }
